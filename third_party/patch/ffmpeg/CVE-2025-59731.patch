diff -Npur ffmpeg-5.1.4/libavcodec/exr.c ffmpeg-5.1.4-change/libavcodec/exr.c
--- ffmpeg-5.1.4/libavcodec/exr.c	2023-11-10 07:38:54.000000000 +0800
+++ ffmpeg-5.1.4-change/libavcodec/exr.c	2025-11-05 15:51:09.249083364 +0800
@@ -996,6 +996,7 @@ static int dwa_uncompress(EXRContext *s,
     const int dc_h = td->ysize >> 3;
     GetByteContext gb, agb;
     int skip, ret;
+    int have_rle = 0;
 
     if (compressed_size <= 88)
         return AVERROR_INVALIDDATA;
@@ -1020,6 +1021,11 @@ static int dwa_uncompress(EXRContext *s,
     )
         return AVERROR_INVALIDDATA;
 
+    if ((uint64_t)rle_raw_size > INT_MAX) {
+        avpriv_request_sample(s->avctx, "Too big rle_raw_size");
+        return AVERROR_INVALIDDATA;
+    }
+
     bytestream2_init(&gb, src + 88, compressed_size - 88);
     skip = bytestream2_get_le16(&gb);
     if (skip < 2)
@@ -1090,6 +1096,9 @@ static int dwa_uncompress(EXRContext *s,
     if (rle_raw_size > 0 && rle_csize > 0 && rle_usize > 0) {
         unsigned long dest_len = rle_usize;
 
+        if (2LL * td->xsize * td->ysize > rle_raw_size)
+            return AVERROR_INVALIDDATA;
+
         av_fast_padded_malloc(&td->rle_data, &td->rle_size, rle_usize);
         if (!td->rle_data)
             return AVERROR(ENOMEM);
@@ -1106,6 +1115,8 @@ static int dwa_uncompress(EXRContext *s,
         if (ret < 0)
             return ret;
         bytestream2_skip(&gb, rle_csize);
+
+        have_rle = 1;
     }
 
     bytestream2_init(&agb, td->ac_data, ac_count * 2);
@@ -1163,7 +1174,7 @@ static int dwa_uncompress(EXRContext *s,
     if (s->nb_channels < 4)
         return 0;
 
-    for (int y = 0; y < td->ysize && td->rle_raw_data; y++) {
+    for (int y = 0; y < td->ysize && have_rle; y++) {
         uint32_t *ao = ((uint32_t *)td->uncompressed_data) + y * td->xsize * s->nb_channels;
         uint8_t *ai0 = td->rle_raw_data + y * td->xsize;
         uint8_t *ai1 = td->rle_raw_data + y * td->xsize + rle_raw_size / 2;

